using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.IO;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using ClickHouse.Driver.Logging;
using ClickHouse.Driver.Utility;
using Microsoft.Extensions.Logging;

namespace ClickHouse.Driver.ADO;

public class ClickHouseConnection : DbConnection, IClickHouseConnection, ICloneable, IDisposable
{
    private volatile ConnectionState state = ConnectionState.Closed; // Not an autoproperty because of interface implementation
    private bool ownsClient = true;
    private string selectedDatabase;

    internal ClickHouseClient ClickHouseClient { get; private set; }

    public ClickHouseConnection()
        : this(string.Empty)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class.
    /// Create a ClickHouseConnection based on a connection string, optionally skipping certificate validation. This will create a new internal connection pool.
    /// It is recommended to pass a ClickHouseClient to the Connection, or to use ClickHouseDataSource instead.
    /// </summary>
    public ClickHouseConnection(string connectionString)
        : this(ClickHouseClientSettings.FromConnectionString(connectionString))
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class.
    /// Create a ClickHouseConnection based on a connection string, optionally skipping certificate validation. This will create a new internal connection pool.
    /// It is recommended to pass a ClickHouseClient to the Connection, or to use ClickHouseDataSource instead.
    /// </summary>
    public ClickHouseConnection(string connectionString, bool skipServerCertificateValidation)
    {
        var settings = new ClickHouseClientSettings(connectionString)
        {
            SkipServerCertificateValidation = skipServerCertificateValidation,
        };

        ClickHouseClient = new ClickHouseClient(settings);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using provided HttpClient.
    /// Note that HttpClient must have AutomaticDecompression enabled if compression is not disabled in connection string
    /// </summary>
    /// <param name="connectionString">Connection string</param>
    /// <param name="httpClient">instance of HttpClient</param>
    public ClickHouseConnection(string connectionString, HttpClient httpClient)
    {
        var settings = new ClickHouseClientSettings(connectionString)
        {
            HttpClient = httpClient,
        };

        ClickHouseClient = new ClickHouseClient(settings);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using an HttpClient generated by the provided <paramref name="httpClientFactory"/>.
    /// </summary>
    /// <param name="connectionString">The ClickHouse connection string.</param>
    /// <param name="httpClientFactory">The factory to be used for creating the clients.</param>
    /// <param name="httpClientName">
    /// The name of the HTTP client you want to be created using the provided factory.
    /// If left empty, the default client will be created.
    /// </param>
    /// <remarks>
    /// <list type="bullet">
    /// <item>
    /// If compression is not disabled in the <paramref name="connectionString"/>, the <paramref name="httpClientFactory"/>
    /// must be configured to enable <see cref="HttpClientHandler.AutomaticDecompression"/> for its generated clients.
    /// <example>
    /// For example you can do this while registering the HTTP client:
    /// <code>
    /// services.AddHttpClient("ClickHouseClient").ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    /// {
    ///     AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
    /// });
    /// </code>
    /// </example>
    /// </item>
    /// <item>
    /// The <paramref name="httpClientFactory"/> must set the timeout for its clients if needed.
    /// <example>
    /// For example you can do this while registering the HTTP client:
    /// <code>
    /// services.AddHttpClient("ClickHouseClient", c => c.Timeout = TimeSpan.FromMinutes(5));
    /// </code>
    /// </example>
    /// </item>
    /// </list>
    /// </remarks>
    public ClickHouseConnection(string connectionString, IHttpClientFactory httpClientFactory, string httpClientName = "")
    {
        var settings = new ClickHouseClientSettings(connectionString)
        {
            HttpClientFactory = httpClientFactory,
            HttpClientName = httpClientName,
        };

        ClickHouseClient = new ClickHouseClient(settings);
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using an existing client.
    /// The connection does not own the client and will not dispose it.
    /// </summary>
    /// <param name="clickHouseClient">The client to use for this connection.</param>
    public ClickHouseConnection(ClickHouseClient clickHouseClient)
    {
        ClickHouseClient = clickHouseClient;
        ownsClient = false;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ClickHouseConnection"/> class using ClickHouseClientSettings.
    /// </summary>
    /// <param name="settings">The settings to use for this connection</param>
    public ClickHouseConnection(ClickHouseClientSettings settings)
    {
        if (settings == null)
            throw new ArgumentNullException(nameof(settings));
        ClickHouseClient = new ClickHouseClient(settings);
    }

    /// <summary>
    /// Gets the string defining connection settings for ClickHouse server
    /// Example: Host=localhost;Port=8123;Username=default;Password=123;Compression=true
    /// It is generally recommended create a new connection instead of modifying the settings of an existing one.
    /// Setting a new connection string will create a new ClickHouseClient instance under the hood.
    /// </summary>
    public sealed override string ConnectionString
    {
        // Some users require ConnectionString to be set after creation
        get => ClickHouseClient.ConnectionStringBuilder.ToString();
        set => Settings = new ClickHouseClientSettings(value);
    }

    /// <summary>
    /// Gets or sets the connection settings.
    /// Warning: updating the settings will create a new ClickHouseClient instance under the hood.
    /// </summary>
    public ClickHouseClientSettings Settings
    {
        get => ClickHouseClient.Settings;
        set
        {
            if (State == ConnectionState.Open)
                throw new InvalidOperationException("Cannot change settings while connection is open.");

            ApplySettings(value);
        }
    }

    public IDictionary<string, object> CustomSettings => Settings?.CustomSettings;

    public override ConnectionState State => state;

    public override string Database => selectedDatabase ?? Settings.Database;

    public override string DataSource { get; }

    public override string ServerVersion => throw new InvalidOperationException(
        "ServerVersion is no longer available. Use ExecuteScalarAsync(\"SELECT version()\") to query the server version.");

    public bool UseCompression => Settings.UseCompression;

    public bool SkipServerCertificateValidation => Settings.SkipServerCertificateValidation;

    public bool UseFormDataParameters => Settings.UseFormDataParameters;

    private void ApplySettings(ClickHouseClientSettings settings)
    {
        settings.Validate();
        DisposeClientIfOwned();
        ClickHouseClient = new ClickHouseClient(settings);
        ownsClient = true;
    }

    public override DataTable GetSchema() => GetSchema(null, null);

    public override DataTable GetSchema(string collectionName) => GetSchema(collectionName, null);

    public override DataTable GetSchema(string collectionName, string[] restrictionValues) =>
        SchemaDescriber.DescribeSchema(this, collectionName, restrictionValues);

    public override void ChangeDatabase(string databaseName)
    {
        selectedDatabase = databaseName;
    }

    public object Clone() => new ClickHouseConnection(ClickHouseClient);

    public override void Close() => state = ConnectionState.Closed;

    public override void Open() => OpenAsync().ConfigureAwait(false).GetAwaiter().GetResult();

    public override Task OpenAsync(CancellationToken cancellationToken)
    {
        ClickHouseClient.GetLogger(ClickHouseLogCategories.Connection)?.LogDebug("Opening ClickHouse connection to {Endpoint}.", ClickHouseClient.ServerUri);
        state = ConnectionState.Open;
        return Task.CompletedTask;
    }

    /// <summary>
    /// Warning: implementation-specific API. Exposed to allow custom optimizations
    /// May change in future versions
    /// </summary>
    /// <param name="sql">SQL query to add to URL, may be empty</param>
    /// <param name="data">Raw stream to be sent. May contain SQL query at the beginning. May be gzip-compressed</param>
    /// <param name="isCompressed">indicates whether "Content-Encoding: gzip" header should be added</param>
    /// <param name="token">Cancellation token</param>
    /// <param name="queryId">Query id</param>
    /// <returns>Task-wrapped HttpResponseMessage object</returns>
    public async Task<HttpResponseMessage> PostStreamAsync(string sql, Stream data, bool isCompressed, CancellationToken token, string queryId = null)
    {
        var options = GetQueryOptionsWithQueryId(queryId);
        return await ClickHouseClient.PostStreamAsync(sql, data, isCompressed, token, options).ConfigureAwait(false);
    }

    /// <summary>
    /// Warning: implementation-specific API. Exposed to allow custom optimizations
    /// May change in future versions
    /// </summary>
    /// <param name="sql">SQL query to add to URL, may be empty</param>
    /// <param name="callback">Callback invoked to write to the stream. May contain SQL query at the beginning. May be gzip-compressed</param>
    /// <param name="isCompressed">indicates whether "Content-Encoding: gzip" header should be added</param>
    /// <param name="token">Cancellation token</param>
    /// <param name="queryId">Query id</param>
    /// <returns>Task-wrapped HttpResponseMessage object</returns>
    public async Task<HttpResponseMessage> PostStreamAsync(string sql, Func<Stream, CancellationToken, Task> callback, bool isCompressed, CancellationToken token, string queryId = null)
    {
        var options = GetQueryOptionsWithQueryId(queryId);
        return await ClickHouseClient.PostStreamAsync(sql, callback, isCompressed, token, options).ConfigureAwait(false);
    }

    private static QueryOptions GetQueryOptionsWithQueryId(string queryId)
    {
        QueryOptions options = null;
        if (queryId != null)
        {
            options = new QueryOptions
            {
                QueryId = queryId,
            };
        }
        return options;
    }

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required
    public new ClickHouseCommand CreateCommand(string commandText = null) => new (this) { CommandText = commandText };
#pragma warning restore CS0109 // Member does not hide an inherited member; new keyword is not required

    void IDisposable.Dispose()
    {
        DisposeClientIfOwned();
        GC.SuppressFinalize(this);
    }

    private void DisposeClientIfOwned()
    {
        if (ownsClient)
        {
            ClickHouseClient?.Dispose();
        }
    }

    internal Task EnsureOpenAsync() => state != ConnectionState.Open ? OpenAsync() : Task.CompletedTask;

    protected override DbTransaction BeginDbTransaction(IsolationLevel isolationLevel) => throw new NotSupportedException();

    protected override DbCommand CreateDbCommand() => CreateCommand();
}
